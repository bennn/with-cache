#lang racket/base

;; lightweight, filesystem-based caching

(provide
  *use-cache?*
  ;; (Parameterof Boolean)
  ;; When #f, do not read or save caches, ever.

  *with-cache-fasl?*
  ;; (Parameterof Boolean)
  ;; When #t, store cachefiles in fasl format.
  ;; When #f, directly read/write the values.

  *current-cache-directory*
  ;; (Parameterof Path-String)
  ;; Default directory to save caches in.
  ;; Used as a prefix to `cache-file`

  *current-cache-keys*
  ;; (Parameterof (U #f (Listof (Parameterof Any))))
  ;; List of keys to query when reading/writing the cache

  cachefile
  ;; (cachefile ps)
  ;; Prefix the path string `ps` with the current value of `*CACHE-DIRECTORY*`

  with-cache
  ;; (with-cache path thunk #:read r #:write w)
  ;; Checks `path` for a value `r` can interpret; if so returns the interpreted value.
  ;; Else runs `thunk` and writes the result to `path` using `w`.

  parent-directory-exists?
  ;; (parent-directory-exists? ps)
  ;; Returns #t if `(path-only ps)` exists on the filesystem or is #f

  with-cache-logger
  ;; Logger
  ;; Your trusted source for information about the inner workings of `with-cache`
)

(require
  (only-in racket/file file->value)
  (only-in racket/path path-only)
  (only-in racket/date date-display-format current-date date->string)
  (only-in racket/serialize serialize deserialize)
  (only-in racket/port open-output-nowhere)
  (only-in setup/getinfo get-info)
  racket/fasl
)

;; =============================================================================

(define (get-package-version)
  ((get-info '("with-cache")) 'version))

(define null-dir (gensym 'uninitialized))

(define *use-cache?* (make-parameter #t))
(define *with-cache-fasl?* (make-parameter #t))
(define *current-cache-directory* (make-parameter null-dir))
(define *current-cache-keys* (make-parameter (list get-package-version)))

(define-logger with-cache)

;; -----------------------------------------------------------------------------

(define (cachefile ps)
  (if (not (eq? (*current-cache-directory*) null-dir))
    (build-path (*current-cache-directory*) ps)
    (let* ([cwd (current-directory)]
           [compiled (build-path cwd "compiled")]
           [wc (build-path compiled "with-cache")])
      (cond
       [(not (directory-exists? compiled))
        (build-path cwd ps)]
       [else
        (unless (directory-exists? wc)
          (make-directory wc))
        (build-path wc ps)]))))

(define (with-cache cache-file thunk #:read [read-proc deserialize] #:write [write-proc serialize])
  (let* (;; read parameters
         [use? (*use-cache?*)]
         [fasl? (*with-cache-fasl?*)]
         [keys (*current-cache-keys*)]
         ;; resolve read&write functions
         [read-proc (read/keys read-proc keys)]
         [write-proc (write/keys write-proc keys)])
    (or ;; -- read from cachefile
        (and use?
             (file-exists? cache-file)
             (with-handlers ([exn:fail? (cache-read-error cache-file)])
               (log-with-cache-info "reading cachefile '~a'..." cache-file)
               (cond
                [(read-proc (call-with-input-file cache-file (if fasl? fasl->s-exp read)))
                 => (λ (read-val)
                      (log-with-cache-info "successfully read cachefile '~a'" cache-file)
                      read-val)]
                [else #f])))
        ;; -- write new cachefile
        (let ([r (thunk)])
          (when use?
            (define val-to-write
              (with-handlers ([exn:fail? (λ (exn) (raise-user-error 'with-cache "Internal error: failed to make writable value from result '~e'" r))])
                (write-proc r)))
            (log-with-cache-info "writing cachefile '~a'" cache-file)
            (with-handlers ([exn:fail? (cache-write-error cachefile)])
              (with-output-to-file cache-file #:exists 'replace
                (λ ()
                  (parameterize ([date-display-format 'iso-8601])
                    (printf ";; This file was generated by the `with-cache` library on ~a~n" (date->string (current-date))))
                  (if fasl?
                      (s-exp->fasl val-to-write (current-output-port))
                      (writeln val-to-write))
                  (log-with-cache-info "successfully wrote to cachefile '~a'" cache-file)))))
          r))))

(define (parent-directory-exists? ps)
  (and (path-string? ps)
       (let ([dir (path-only ps)])
         (or (not dir) (directory-exists? dir)))))

;; -----------------------------------------------------------------------------

(define (exn->string exn)
  (format "got exception:~n~a~n" (exn-message exn)))

(define (cache-read-error cachefile) ; (-> Path-String (-> Exception #f))
  (define msg-prefix (format "Failed to read cachefile '~a'" cachefile))
  (λ (exn)
    (log-with-cache-error (string-append msg-prefix ", " (exn->string exn)))
    #f))

(define (cache-write-error cachefile) ; (-> Path-String (-> Exception #f))
  (define msg-prefix (format "Failed to write cachefile '~a'" cachefile))
  (define err-prefix (format "Internal error: failed to delete malformed cachefile '~a'" cachefile))
  (λ (exn)
    (log-with-cache-error (string-append msg-prefix ", " (exn->string exn)))
    (define (err-handler e)
      (raise-user-error 'with-cache (string-append err-prefix ", " (exn->string e))))
    (with-handlers ([exn:fail:filesystem? err-handler])
      (when (file-exists? cachefile)
        (delete-file cachefile)))
    #f))

(define (read/keys read-proc keys)
  (if (and keys (not (null? keys)))
    (λ (v)
      (and (pair? v)
           (list? (car v))
           (equal? (car v) (keys->vals keys))
           (read-proc (cdr v))))
    read-proc))

(define (write/keys write-proc keys)
  (if (and keys (not (null? keys)))
    (λ (v)
      (cons (keys->vals keys) (write-proc v)))
    write-proc))

(define (keys->vals key-thunks)
  (for/list ([t (in-list key-thunks)])
    (t)))

;; =============================================================================

(module+ test
  (require rackunit racket/string racket/logging racket/port version/utils)

  (define ccm (current-continuation-marks))

  (define msg1 "with-cache:test:sample-message")
  (define exn1 (make-exn msg1 ccm))

  (define msg/filesystem "with-cache:test:filesystem")
  (define exn/filesystem (make-exn:fail:filesystem msg/filesystem ccm))

  (define cachefile1 "foo/bar/tmp.dat")
  (define cachefile/no-parent "with-cache-test.dat")

  (define (intercept-with-cache-log thunk [level 'info])
    (define inbox (make-hasheq '((debug . ()) (info . ()) (warning . ()) (error . ()) (fatal . ()))))
    (with-intercepted-logging
      (λ (l)
        (define lvl (vector-ref l 0))
        (define msg (vector-ref l 1))
        (when (eq? 'with-cache (vector-ref l 3))
          (hash-set! inbox lvl (cons msg (hash-ref inbox lvl))))
        (void))
      thunk
      #:logger with-cache-logger
      level)
    inbox)

  (test-case "exn->string"
    (define (check-exn->string msg exn)
      (let ([str (exn->string exn)])
        (check-true (string? str))
        (check-true (string-prefix? str "got exception"))
        (check-true (string-contains? str msg))))

    (check-exn->string msg1 exn1)
    (check-exn->string msg/filesystem exn/filesystem))

  ;; TODO test passes, but prints to the default logger. No bueno.
  (test-case "cache-read-error"

    (define (check-cache-read-error cachefile exn)
      (define logs
        (intercept-with-cache-log
          (lambda ()
            (check-false ((cache-read-error cachefile) exn)))
          'error))
      (define errs (hash-ref logs 'error))
      (check-equal? (length errs) 1)
      (define msg (car errs))
      (check-true (string-contains? msg "Failed to read"))
      (check-true (string-contains? msg cachefile))
      (check-true (string-contains? msg (exn-message exn))))

    (check-cache-read-error cachefile1 exn1)
    (check-cache-read-error cachefile1 exn/filesystem))

  (test-case "cache-write-error"

    (define (check-cache-write-error cachefile exn)
      (define logs
        (intercept-with-cache-log
          (lambda ()
            (check-false ((cache-write-error cachefile) exn)))
          'error))
      (define errs (hash-ref logs 'error))
      (check-equal? (length errs) 1)
      (define msg (car errs))
      (check-true (string-contains? msg "Failed to write"))
      (check-true (string-contains? msg cachefile))
      (check-true (string-contains? msg (exn-message exn))))

    (check-cache-write-error cachefile1 exn1)
    (check-cache-write-error cachefile1 exn/filesystem))

  (test-case "read+write/keys:no-keys"
    (define x (gensym 'x))
    (define y (gensym 'y))

    (check-equal?
      ((write/keys (λ (_) x) (list)) y)
      x)

    (check-equal?
      ((read/keys (λ (_) x) (list)) y)
      x))

  (test-case "read+write/keys:some-keys"
    (define x (gensym 'x))
    (define y (gensym 'y))

    (define good-keys (list (λ () y)))
    (define bad-keys (list (λ () x)))

    (define id (λ (z) z))

    (define v0 ((write/keys id good-keys) x))
    (check-not-equal? v0 x)
    (check-equal? ((read/keys id good-keys) v0) x)

    (check-false ((read/keys id bad-keys) v0) x))

  (test-case "keys->vals"
    (define v0 #t)
    (define v1 (gensym))

    (parameterize ([*use-cache?* v0])
      (check-equal?
        (keys->vals (list *use-cache?* *use-cache?*))
        (list v0 v0)))

    (check-equal?
      (keys->vals (list (λ () v0) (λ () v1)))
      (list v0 v1)))

  (test-case "get-package-version"
    (check-true (valid-version? (get-package-version))))

)
