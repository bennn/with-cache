#lang racket/base

;; lightweight, filesystem-based caching

(provide
  *use-cache?*
  ;; (Parameterof Boolean)
  ;; When #f, do not read or save caches, ever.

  *with-cache-fasl?*
  ;; (Parameterof Boolean)
  ;; When #t, store cachefiles in fasl format.
  ;; When #f, directly read/write the values.

  *current-cache-directory*
  ;; (Parameterof Path-String)
  ;; Default directory to save caches in.
  ;; Used as a prefix to `cache-file`

  *current-cache-keys*
  ;; (Parameterof (U #f (Listof (Parameterof Any))))
  ;; List of keys to query when reading/writing the cache

  *keys-equal?*
  ;; (Parameterof equivalence/c)
  ;; Use to override the way `with-cache` checks that keys are equal.

  cachefile
  ;; (cachefile ps)
  ;; Prefix the path string `ps` with the current value of `*CACHE-DIRECTORY*`

  with-cache
  ;; (with-cache path thunk #:read r #:write w #:use-cache? c #:fasl? f #:keys k*)
  ;; Checks `path` for a value `r` can interpret; if so returns the interpreted value.
  ;; Else runs `thunk` and writes the result to `path` using `w`.
  ;; Optional arguments (#:use-cache? #:fasl? #:keys) override the default values
  ;;  for the (*use-cache?* *with-cache-fasl?* *current-cache-keys*) parameters

  parent-directory-exists?
  ;; (parent-directory-exists? ps)
  ;; Returns #t if `(path-only ps)` exists on the filesystem or is #f

  with-cache-logger
  ;; Logger
  ;; Your trusted source for information about the inner workings of `with-cache`

  get-with-cache-version
  ;; (-> valid-version?)
  ;; Return version of this package.
)

(require
  (only-in racket/file file->value call-with-file-lock/timeout make-lock-file-name make-directory*)
  (only-in racket/path path-only)
  (only-in racket/date date-display-format current-date date->string)
  (only-in racket/serialize serialize deserialize)
  (only-in racket/port open-output-nowhere)
  (only-in setup/getinfo get-info)
  racket/fasl
)

;; =============================================================================

(define (get-with-cache-version)
  ((get-info '("with-cache")) 'version))

(define no-keys (string->symbol (string-append "no-keys:" (get-with-cache-version))))

(define *use-cache?* (make-parameter #t))
(define *with-cache-fasl?* (make-parameter #t))
(define *current-cache-directory* (make-parameter (build-path (current-directory) "compiled" "with-cache")))
(define *current-cache-keys* (make-parameter (list get-with-cache-version)))
(define *keys-equal?* (make-parameter equal?))

(define-logger with-cache)

(define (no-keys? x)
  (eq? x no-keys))

;; -----------------------------------------------------------------------------

(define (cachefile ps)
  (define ccd (*current-cache-directory*))
  (unless (directory-exists? ccd)
    (make-directory* ccd))
  (build-path ccd ps))

(define (with-cache cache-file
                    thunk
                    #:use-cache? [use? (*use-cache?*)]
                    #:fasl? [fasl? (*with-cache-fasl?*)]
                    #:keys [keys (*current-cache-keys*)]
                    #:keys-equal? [keys-equal? (*keys-equal?*)]
                    #:read [read-proc deserialize]
                    #:write [write-proc serialize])
  (let* (;; resolve read&write functions
         [read-proc (read/keys read-proc keys keys-equal?)]
         [write-proc (write/keys write-proc keys)])
    (or ;; -- read from cachefile
        (and use?
             (file-exists? cache-file)
             (with-handlers ([exn:fail? (cache-read-error cache-file)])
               (log-with-cache-info "reading cache file '~a'..." cache-file)
               (cond
                [(read-proc (call-with-atomic-input-file cache-file (if fasl? fasl->s-exp read)))
                 => (λ (read-val)
                      (log-with-cache-info "successfully read cache file '~a'" cache-file)
                      read-val)]
                [else #f])))
        ;; -- write new cache file
        (let ([r (thunk)])
          (when use?
            (define val-to-write
              (with-handlers ([exn:fail? (λ (exn) (raise-user-error 'with-cache "Internal error: failed to make writable value from result '~e'" r))])
                (write-proc r)))
            (log-with-cache-info "writing cache file '~a'" cache-file)
            (with-handlers ([exn:fail? (cache-write-error cache-file)])
              (call-with-atomic-output-file cache-file
                (λ (out)
                  (if fasl?
                      (s-exp->fasl val-to-write out)
                      (begin
                        (parameterize ([date-display-format 'iso-8601])
                          (fprintf out ";; This file was generated by the `with-cache` library on ~a~n" (date->string (current-date))))
                        (writeln val-to-write out)))
                  (log-with-cache-info "successfully wrote to cache file '~a'" cache-file)))))
          r))))

;; -----------------------------------------------------------------------------

(define (exn->string exn)
  (format "got exception:~n~a" (exn-message exn)))

(define (cache-read-error cache-file) ; (-> Path-String (-> Exception #f))
  (define msg-prefix (format "Failed to read cache file '~a'" cache-file))
  (CI-case
    (λ (exn)
      (log-with-cache-info (string-append msg-prefix ", " (exn->string exn)))
      #f)
    (λ (exn)
      (log-with-cache-error (string-append msg-prefix ", " (exn->string exn)))
      #f)))

(define (cache-write-error cache-file) ; (-> Path-String (-> Exception #f))
  (define msg-prefix (format "Failed to write cache file '~a'" cache-file))
  (define err-prefix (format "Internal error: failed to delete malformed cache file '~a'" cache-file))
  (CI-case
    (λ (exn)
      (log-with-cache-info (string-append msg-prefix ", " (exn->string exn)))
      (define (err-handler e)
        (raise-user-error 'with-cache (string-append err-prefix ", " (exn->string e))))
      (with-handlers ([exn:fail:filesystem? err-handler])
        (when (file-exists? cache-file)
          (delete-file cache-file)))
      #f)
    (λ (exn)
      (log-with-cache-error (string-append msg-prefix ", " (exn->string exn)))
      (define (err-handler e)
        (raise-user-error 'with-cache (string-append err-prefix ", " (exn->string e))))
      (with-handlers ([exn:fail:filesystem? err-handler])
        (when (file-exists? cache-file)
          (delete-file cache-file)))
      #f)))

(define (call-with-atomic-input-file filename success-proc)
  (call/atomic filename (λ () (call-with-input-file filename success-proc))))

(define (call-with-atomic-output-file filename success-proc)
  (call/atomic filename (λ () (call-with-output-file filename success-proc #:exists 'replace))))

(define (call/atomic filename success-thunk)
  (define lockfile (make-lock-file-name
                     (build-path (find-system-path 'temp-dir)
                                 (format "with-cache~a" (equal-hash-code filename)))))
  (call-with-file-lock/timeout filename
                               'exclusive
                               success-thunk
                               (λ ()
                                 (raise (exn:fail:filesystem
                                          (format "with-cache: Failed to lock file '~a', delete the lock '~a' and try again." filename lockfile)
                                          (current-continuation-marks))))
                               #:lock-file lockfile))

(define (parent-directory-exists? ps)
  (and (path-string? ps)
       (let ([dir (path-only ps)])
         (or (not dir) (directory-exists? dir)))))

(define (read/keys read-proc keys keys-equal?)
  (if (and keys (not (null? keys)))
    (λ (v)
      (and (pair? v)
           (list? (car v))
           (keys-equal? (car v) (keys->vals keys))
           (read-proc (cdr v))))
    (λ (v)
      (and (pair? v)
           (no-keys? (car v))
           (read-proc (cdr v))))))

(define (write/keys write-proc keys)
  (if (and keys (not (null? keys)))
    (λ (v)
      (cons (keys->vals keys) (write-proc v)))
    (λ (v)
      (cons no-keys (write-proc v)))))

(define (keys->vals key-thunks)
  (for/list ([t (in-list key-thunks)])
    (t)))

(define-syntax-rule (CI-case a b)
  (if (equal? "true" (getenv "CI")) a b))

;; =============================================================================

(module+ test
  (require rackunit racket/string racket/logging racket/port racket/runtime-path version/utils)

  (define ccm (current-continuation-marks))

  (define msg1 "with-cache:test:sample-message")
  (define exn1 (make-exn msg1 ccm))

  (define msg/filesystem "with-cache:test:filesystem")
  (define exn/filesystem (make-exn:fail:filesystem msg/filesystem ccm))

  (define cachefile1 "foo/bar/tmp.dat")
  (define cachefile/no-parent "with-cache-test.dat")

  (define (intercept-with-cache-log thunk [level 'info])
    (define inbox (make-hasheq '((debug . ()) (info . ()) (warning . ()) (error . ()) (fatal . ()))))
    (with-intercepted-logging
      (λ (l)
        (define lvl (vector-ref l 0))
        (define msg (vector-ref l 1))
        (when (eq? 'with-cache (vector-ref l 3))
          (hash-set! inbox lvl (cons msg (hash-ref inbox lvl))))
        (void))
      thunk
      #:logger with-cache-logger
      level)
    inbox)

  (define-runtime-path test-file "./atomic-test-file.rktd")

  (define ERROR-LEVEL
    (CI-case
      'info
      'error))

  (test-case "exn->string"
    (define (check-exn->string msg exn)
      (let ([str (exn->string exn)])
        (check-true (string? str))
        (check-true (string-prefix? str "got exception"))
        (check-true (string-contains? str msg))))

    (check-exn->string msg1 exn1)
    (check-exn->string msg/filesystem exn/filesystem))

  (test-case "cache-read-error"

    (define (check-cache-read-error cachefile exn)
      (define logs
        (intercept-with-cache-log
          (lambda ()
            (check-false ((cache-read-error cachefile) exn)))
          ERROR-LEVEL))
      (define errs (hash-ref logs ERROR-LEVEL))
      (check-equal? (length errs) 1)
      (define msg (car errs))
      (check-true (string-contains? msg "Failed to read"))
      (check-true (string-contains? msg cachefile))
      (check-true (string-contains? msg (exn-message exn))))

    (check-cache-read-error cachefile1 exn1)
    (check-cache-read-error cachefile1 exn/filesystem))

  (test-case "cache-write-error"

    (define (check-cache-write-error cachefile exn)
      (define logs
        (intercept-with-cache-log
          (lambda ()
            (check-false ((cache-write-error cachefile) exn)))
          ERROR-LEVEL))
      (define errs (hash-ref logs ERROR-LEVEL))
      (check-equal? (length errs) 1)
      (define msg (car errs))
      (check-true (string-contains? msg "Failed to write"))
      (check-true (string-contains? msg cachefile))
      (check-true (string-contains? msg (exn-message exn))))

    (check-cache-write-error cachefile1 exn1)
    (check-cache-write-error cachefile1 exn/filesystem))

  (test-case "call/atomic"
    (define msg
      (with-handlers ([exn:fail:filesystem? exn-message])
        (call-with-atomic-output-file test-file
          (λ (out-port)
            (call-with-atomic-input-file test-file
              (λ (in-port) (check-true #f)))))))

    (check-regexp-match #rx"Failed to lock file" msg)
    (check-regexp-match #rx"delete the lock" msg)
  )

  (test-case "read+write/keys:no-keys"
    (define x (gensym 'x))
    (define y (gensym 'y))

    (check-equal?
      ((write/keys (λ (_) x) (list)) y)
      (cons no-keys x))

    (check-equal?
      ((read/keys (λ (_) x) (list) equal?) (cons no-keys y))
      x)

    (check-equal?
      ((read/keys (λ (_) x) (list) equal?) y)
      #f))

  (test-case "read+write/keys:some-keys"
    (define x (gensym 'x))
    (define y (gensym 'y))

    (define good-keys (list (λ () y)))
    (define bad-keys (list (λ () x)))

    (define id (λ (z) z))

    (define v0 ((write/keys id good-keys) x))
    (check-not-equal? v0 x)
    (check-equal? ((read/keys id good-keys equal?) v0) x)

    (check-false ((read/keys id bad-keys equal?) v0)))

  (test-case "keys->vals"
    (define v0 #t)
    (define v1 (gensym))

    (parameterize ([*use-cache?* v0])
      (check-equal?
        (keys->vals (list *use-cache?* *use-cache?*))
        (list v0 v0)))

    (check-equal?
      (keys->vals (list (λ () v0) (λ () v1)))
      (list v0 v1)))

  (test-case "get-with-cache-version"
    (check-true (valid-version? (get-with-cache-version))))

)
